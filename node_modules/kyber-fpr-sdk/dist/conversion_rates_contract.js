'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompactDataLocation = exports.RateSetting = exports.StepFunctionDataPoint = exports.TokenControlInfo = exports.buildCompactBulk = exports.CompactData = undefined;

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _web = require('web3');

var _web2 = _interopRequireDefault(_web);

var _bignumber = require('bignumber.js');

var _bignumber2 = _interopRequireDefault(_bignumber);

var _base_contract = require('./base_contract.js');

var _base_contract2 = _interopRequireDefault(_base_contract);

var _ConversionRatesContractAbi = require('../abi/ConversionRatesContract.abi.json');

var _ConversionRatesContractAbi2 = _interopRequireDefault(_ConversionRatesContractAbi);

var _validate = require('./validate.js');

var _permission_assert = require('./permission_assert.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * CompactData is used to save gas on get, set rates operations.
 * Instead of sending the whole buy, sell rates every time, only the different
 * is sent if possible.
 * The compact rate is calculated by following formula:
 *
 *      compact = ((rate / base) - 1) * 1000
 */
var CompactData = exports.CompactData = function () {
  (0, _createClass3.default)(CompactData, [{
    key: 'isBaseChanged',
    get: function get() {
      return this._isBaseChanged;
    },
    set: function set(value) {
      this._isBaseChanged = value;
    }
  }, {
    key: 'compact',
    get: function get() {
      return this._compact;
    },
    set: function set(value) {
      this._compact = value;
    }
  }, {
    key: 'base',
    get: function get() {
      return this._base;
    },
    set: function set(value) {
      this._base = value;
    }

    /**
     * Create a new CompactData instance.
     * @param {BigNumber} rate - the total rate
     * @param {BigNumber} base - the base to generate compact data
     */

  }]);

  function CompactData(rate, base) {
    (0, _classCallCheck3.default)(this, CompactData);

    // const compactData = buildCompactData(rate, base)
    var minInt8 = -128;
    var maxInt8 = 127;

    rate = new _bignumber2.default(rate);
    base = new _bignumber2.default(base);

    var compact = void 0;

    if (base.isEqualTo(0)) {
      base = rate;
      this.isBaseChanged = true;
      compact = new _bignumber2.default(0);
    } else {
      compact = rate.dividedBy(base).minus(new _bignumber2.default(1)).multipliedBy(1000.0).integerValue();

      // compact data is fit in a byte
      if (compact.isGreaterThanOrEqualTo(minInt8) && compact.isLessThanOrEqualTo(maxInt8)) {
        // overflowed, convert from int8 to byte so
        // * -1 --> 255
        // * -128 --> 128
        if (compact.isLessThan(0)) {
          compact = new _bignumber2.default(Math.pow(2, 8)).plus(compact);
        }
      } else {
        base = rate;
        this.isBaseChanged = true;
        compact = new _bignumber2.default(0);
      }
    }

    this._base = base;
    this._compact = compact;
  }

  return CompactData;
}();

/**
 * Build the compact data input.
 * In ConversionRates contract, the compact data is stored in two dimensions
 * array with location:
 *   - bulkIndex
 *   - indexInBulk
 *
 * When setting compact data, user needs to submit the whole bulk along with
 * its index.
 *
 * @param newBuys - buy compact data
 * @param newSells - sell compact data
 * @param indices - map of address to its bulk index
 * @return {{buyResults: Array, sellResults: Array, indexResults: Array}}
 */


var buildCompactBulk = exports.buildCompactBulk = function buildCompactBulk(newBuys, newSells, indices) {
  var buyResults = [];
  var sellResults = [];
  var indexResults = [];
  var buyBulks = {};
  var sellBulks = {};

  for (var addr in newBuys) {
    if (newBuys.hasOwnProperty(addr)) {
      var loc = indices[addr];
      if (!(loc.bulkIndex in buyBulks)) {
        buyBulks[loc.bulkIndex] = new Array(14).fill(0);
        sellBulks[loc.bulkIndex] = new Array(14).fill(0);
      }
      buyBulks[loc.bulkIndex][loc.indexInBulk] = newBuys[addr];
      sellBulks[loc.bulkIndex][loc.indexInBulk] = newSells[addr];
    }
  }

  for (var i in buyBulks) {
    if (buyBulks.hasOwnProperty(i)) {
      buyResults.push(buyBulks[i]);
      sellResults.push(sellBulks[i]);
      indexResults.push(i);
    }
  }
  return { buyResults: buyResults, sellResults: sellResults, indexResults: indexResults };
};

/**
 * TokenControlInfo is the configurations of a ERC20 token.
 */

var TokenControlInfo = exports.TokenControlInfo = function () {
  (0, _createClass3.default)(TokenControlInfo, [{
    key: 'maxTotalImbalance',
    get: function get() {
      return this._maxTotalImbalance;
    },
    set: function set(value) {
      this._maxTotalImbalance = value;
    }
  }, {
    key: 'maxPerBlockImbalance',
    get: function get() {
      return this._maxPerBlockImbalance;
    },
    set: function set(value) {
      this._maxPerBlockImbalance = value;
    }
  }, {
    key: 'minimalRecordResolution',
    get: function get() {
      return this._minimalRecordResolution;
    },
    set: function set(value) {
      this._minimalRecordResolution = value;
    }

    /**
     * Create a new TokenControlInfo instance.
     * @param minimalRecordResolution {uint} - minimum denominator in token wei that can be changed
     * @param maxPerBlockImbalance {uint} - maximum wei amount of net absolute (+/-) change for a token in an ethereum
     * block
     * @param maxTotalImbalance {uint} - wei amount of the maximum net token change allowable that happens between 2
     * price updates
     */

  }]);

  function TokenControlInfo(minimalRecordResolution, maxPerBlockImbalance, maxTotalImbalance) {
    (0, _classCallCheck3.default)(this, TokenControlInfo);

    this._minimalRecordResolution = minimalRecordResolution;
    this._maxPerBlockImbalance = maxPerBlockImbalance;
    this._maxTotalImbalance = maxTotalImbalance;
  }

  return TokenControlInfo;
}();

// StepFunctionDataPoint is the data point of a step function.


var StepFunctionDataPoint = exports.StepFunctionDataPoint = function () {
  (0, _createClass3.default)(StepFunctionDataPoint, [{
    key: 'y',
    get: function get() {
      return this._y;
    },
    set: function set(value) {
      this._y = value;
    }
  }, {
    key: 'x',
    get: function get() {
      return this._x;
    },
    set: function set(value) {
      this._x = value;
    }

    /**
     * Create a new StepFunctionDataPoint.
     * @param x {int} - buy step in wei amount
     * @param y {int} - impact on buy rate in basis points (bps). 1 bps = 0.01%
     */

  }]);

  function StepFunctionDataPoint(x, y) {
    (0, _classCallCheck3.default)(this, StepFunctionDataPoint);

    this._x = x;
    this._y = y;
  }

  return StepFunctionDataPoint;
}();

/**
 * RateSetting represents the buy sell rates of a ERC20 token.
 */


var RateSetting = exports.RateSetting = function () {
  (0, _createClass3.default)(RateSetting, [{
    key: 'sell',
    get: function get() {
      return this._sell;
    },
    set: function set(value) {
      this._sell = value;
    }
  }, {
    key: 'buy',
    get: function get() {
      return this._buy;
    },
    set: function set(value) {
      this._buy = value;
    }
  }, {
    key: 'address',
    get: function get() {
      return this._address;
    },
    set: function set(value) {
      this._address = value;
    }

    /**
     * Create a new RateSetting instance.
     * @param {string} address - ERC20 token address
     * @param {number} buy - buy rate per ETH
     * @param {number} sell - sell rate per ETH
     */

  }]);

  function RateSetting(address, buy, sell) {
    (0, _classCallCheck3.default)(this, RateSetting);

    (0, _validate.validateAddress)(address);

    this._address = address;
    this._buy = buy;
    this._sell = sell;
    // this._buy = Web3.utils.padLeft(Web3.utils.numberToHex(buy), 14)
    // this._sell = Web3.utils.padLeft(Web3.utils.numberToHex(sell), 14)
  }

  return RateSetting;
}();

/**
 * CompactDataLocation is the location of compact data of a token in
 * ConversionRates contract. When adding a new token, ConversionRatesContract
 * allocated a fixed location in compact data array for it, this can't be
 * changed.
 */


var CompactDataLocation = exports.CompactDataLocation = function () {
  (0, _createClass3.default)(CompactDataLocation, [{
    key: 'indexInBulk',
    get: function get() {
      return this._indexInBulk;
    },
    set: function set(value) {
      this._indexInBulk = value;
    }
  }, {
    key: 'bulkIndex',
    get: function get() {
      return this._bulkIndex;
    },
    set: function set(value) {
      this._bulkIndex = value;
    }
  }]);

  function CompactDataLocation(bulkIndex, indexInBulk) {
    (0, _classCallCheck3.default)(this, CompactDataLocation);

    this._bulkIndex = bulkIndex;
    this._indexInBulk = indexInBulk;
  }

  return CompactDataLocation;
}();

/**
 * ConversionRatesContract represents the KyberNetwork conversion rates smart
 * contract.
 */


var ConversionRatesContract = function (_BaseContract) {
  (0, _inherits3.default)(ConversionRatesContract, _BaseContract);

  /**
   * Create new ConversionRatesContract instance.
   * @param {object} provider - Web3 provider
   * @param {string} address - address of smart contract.
   */
  function ConversionRatesContract(web3, address) {
    var _this2 = this;

    (0, _classCallCheck3.default)(this, ConversionRatesContract);

    var _this = (0, _possibleConstructorReturn3.default)(this, (ConversionRatesContract.__proto__ || (0, _getPrototypeOf2.default)(ConversionRatesContract)).call(this, web3, address));

    _this.web3 = web3;
    _this.contract = new _this.web3.eth.Contract(_ConversionRatesContractAbi2.default, address);

    /**
     * getTokenIndices returns the index of given Token to use in setCompact
     * data call.
     * @param {string} token - ERC 20 token address
     * @return {number} - index ot compact data
     */
    _this.getTokenIndices = function (token) {
      var tokenIndices = {};

      return (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
        var results;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                (0, _validate.validateAddress)(token);

                if (!(token in tokenIndices)) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt('return', tokenIndices[token]);

              case 3:
                results = void 0;
                _context.prev = 4;
                _context.next = 7;
                return _this.contract.methods.getCompactData(token).call();

              case 7:
                results = _context.sent;
                _context.next = 14;
                break;

              case 10:
                _context.prev = 10;
                _context.t0 = _context['catch'](4);

                console.log('failed to query token ' + token + ' for compact data, error: ' + _context.t0);
                return _context.abrupt('return');

              case 14:
                tokenIndices[token] = new CompactDataLocation(results[0], results[1]);
                return _context.abrupt('return', tokenIndices[token]);

              case 16:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this2, [[4, 10]]);
      }))();
    };
    return _this;
  }

  /**
   * Add a ERC20 token and its pricing configurations to reserve contract and
   * enable it for trading.
   * @param {object} adminAccount - admin account address
   * @param {string} token - ERC20 token address
   * @param {TokenControlInfo} tokenControlInfo - https://developer.kyber.network/docs/VolumeImbalanceRecorder#settokencontrolinfo
   * @param {number} gasPrice (optional) - the gasPrice desired for the tx
   */

  (0, _createClass3.default)(ConversionRatesContract, [{
    key: 'addToken',
    value: function () {
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(adminAccount, token, tokenControlInfo, gasPrice) {
        var addTokenTx, controlInfoTx, enableTokenTx;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                (0, _validate.validateAddress)(token);
                _context2.next = 3;
                return (0, _permission_assert.assertAdmin)(this, adminAccount);

              case 3:
                addTokenTx = this.contract.methods.addToken(token);
                _context2.t0 = addTokenTx;
                _context2.t1 = adminAccount;
                _context2.next = 8;
                return addTokenTx.estimateGas({ from: adminAccount });

              case 8:
                _context2.t2 = _context2.sent;
                _context2.t3 = gasPrice;
                _context2.t4 = {
                  from: _context2.t1,
                  gas: _context2.t2,
                  gasPrice: _context2.t3
                };
                _context2.next = 13;
                return _context2.t0.send.call(_context2.t0, _context2.t4);

              case 13:

                console.log("Token Added...");

                controlInfoTx = this.contract.methods.setTokenControlInfo(token, tokenControlInfo.minimalRecordResolution, tokenControlInfo.maxPerBlockImbalance, tokenControlInfo.maxTotalImbalance);
                _context2.t5 = controlInfoTx;
                _context2.t6 = adminAccount;
                _context2.next = 19;
                return controlInfoTx.estimateGas({ from: adminAccount });

              case 19:
                _context2.t7 = _context2.sent;
                _context2.t8 = gasPrice;
                _context2.t9 = {
                  from: _context2.t6,
                  gas: _context2.t7,
                  gasPrice: _context2.t8
                };
                _context2.next = 24;
                return _context2.t5.send.call(_context2.t5, _context2.t9);

              case 24:

                console.log("Token Control Information Updated...");

                enableTokenTx = this.contract.methods.enableTokenTrade(token);
                _context2.t10 = enableTokenTx;
                _context2.t11 = adminAccount;
                _context2.next = 30;
                return enableTokenTx.estimateGas({ from: adminAccount });

              case 30:
                _context2.t12 = _context2.sent;
                _context2.t13 = gasPrice;
                _context2.t14 = {
                  from: _context2.t11,
                  gas: _context2.t12,
                  gasPrice: _context2.t13
                };
                _context2.next = 35;
                return _context2.t10.send.call(_context2.t10, _context2.t14);

              case 35:

                console.log("Token Enabled...");

                return _context2.abrupt('return', this.getTokenIndices(token));

              case 37:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function addToken(_x, _x2, _x3, _x4) {
        return _ref2.apply(this, arguments);
      }

      return addToken;
    }()
    /**
       * Add a ERC20 token and its pricing configurations to reserve contract and
       * enable it for trading.
       * @param {object} adminAccount - admin account address
       * @param {string} token - ERC20 token address
       * @param {TokenControlInfo} tokenControlInfo - https://developer.kyber.network/docs/VolumeImbalanceRecorder#settokencontrolinfo
       * @param {number} gasPrice (optional) - the gasPrice desired for the tx
       */

  }, {
    key: 'updateTokenControlInfo',
    value: function () {
      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(adminAccount, token, tokenControlInfo, gasPrice) {
        var controlInfoTx;
        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                (0, _validate.validateAddress)(token);
                _context3.next = 3;
                return (0, _permission_assert.assertAdmin)(this, adminAccount);

              case 3:
                controlInfoTx = this.contract.methods.setTokenControlInfo(token, tokenControlInfo.minimalRecordResolution, tokenControlInfo.maxPerBlockImbalance, tokenControlInfo.maxTotalImbalance);
                _context3.t0 = controlInfoTx;
                _context3.t1 = adminAccount;
                _context3.next = 8;
                return controlInfoTx.estimateGas({ from: adminAccount });

              case 8:
                _context3.t2 = _context3.sent;
                _context3.t3 = gasPrice;
                _context3.t4 = {
                  from: _context3.t1,
                  gas: _context3.t2,
                  gasPrice: _context3.t3
                };
                _context3.next = 13;
                return _context3.t0.send.call(_context3.t0, _context3.t4);

              case 13:

                console.log("Token Control Information Updated...");

                return _context3.abrupt('return', this.getTokenIndices(token));

              case 15:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function updateTokenControlInfo(_x5, _x6, _x7, _x8) {
        return _ref3.apply(this, arguments);
      }

      return updateTokenControlInfo;
    }()

    /**
     * Set adjustments for tokens' buy and sell rates depending on the net traded
     * amounts. Only operator can invoke.
     * @param {object} operatorAddress - address of the operator account
     * @param {string} token - ERC20 token address
     * @param {StepFunctionDataPoint[]} buy - array of buy step function configurations
     * @param {StepFunctionDataPoint[]} sell - array of sell step function configurations
     * @param {number} [gasPrice=undefined] - the gasPrice desired for the tx
     */

  }, {
    key: 'setImbalanceStepFunction',
    value: function () {
      var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(operatorAddress, token, buy, sell) {
        var gasPrice = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
        var xBuy, yBuy, xSell, ySell, tx;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                (0, _validate.validateAddress)(token);
                _context4.next = 3;
                return (0, _permission_assert.assertOperator)(this, operatorAddress);

              case 3:
                xBuy = buy.map(function (val) {
                  return val.x;
                });
                yBuy = buy.map(function (val) {
                  return val.y;
                });
                xSell = sell.map(function (val) {
                  return val.x;
                });
                ySell = sell.map(function (val) {
                  return val.y;
                });

                if (yBuy > 0) {
                  console.warn('yBuy ' + yBuy + ' is positive, which is contradicted to the logic of setImbalanceStepFunction');
                }
                if (ySell > 0) {
                  console.warn('ySell ' + ySell + ' is positive, which is contradicted to the logic of setImbalanceStepFunction');
                }
                tx = this.contract.methods.setImbalanceStepFunction(token, xBuy, yBuy, xSell, ySell);
                _context4.t0 = tx;
                _context4.t1 = operatorAddress;
                _context4.next = 14;
                return tx.estimateGas({ from: operatorAddress });

              case 14:
                _context4.t2 = _context4.sent;
                _context4.t3 = gasPrice;
                _context4.t4 = {
                  from: _context4.t1,
                  gas: _context4.t2,
                  gasPrice: _context4.t3
                };
                return _context4.abrupt('return', _context4.t0.send.call(_context4.t0, _context4.t4));

              case 18:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function setImbalanceStepFunction(_x10, _x11, _x12, _x13) {
        return _ref4.apply(this, arguments);
      }

      return setImbalanceStepFunction;
    }()

    /**
     * Set adjustments for tokens' buy and sell rates depending on the size of a
     * buy / sell order. Only operator can invoke.
     * @param {object} operatorAddress - address of the operator account
     * @param {string} token - ERC20 token address
     * @param {StepFunctionDataPoint[]} buy - array of buy step function configurations
     * @param {StepFunctionDataPoint[]} sell - array of sell step function configurations
     * @param {number} gasPrice (optional) - the gasPrice desired for the tx
     */

  }, {
    key: 'setQtyStepFunction',
    value: function () {
      var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(operatorAddress, token, buy, sell, gasPrice) {
        var xBuy, yBuy, xSell, ySell, tx;
        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                (0, _validate.validateAddress)(token);
                _context5.next = 3;
                return (0, _permission_assert.assertOperator)(this, operatorAddress);

              case 3:
                xBuy = buy.map(function (val) {
                  return val.x;
                });
                yBuy = buy.map(function (val) {
                  return val.y;
                });
                xSell = sell.map(function (val) {
                  return val.x;
                });
                ySell = sell.map(function (val) {
                  return val.y;
                });

                if (yBuy > 0) {
                  console.warn('yBuy ' + yBuy + ' is positive, which is contradicted to the logic of setQtyStepFunction');
                }
                if (ySell > 0) {
                  console.warn('ySell ' + ySell + ' is positive, which is contradicted to the logic of setQtyStepFunction');
                }
                tx = this.contract.methods.setQtyStepFunction(token, xBuy, yBuy, xSell, ySell);
                _context5.t0 = tx;
                _context5.t1 = operatorAddress;
                _context5.next = 14;
                return tx.estimateGas({ from: operatorAddress });

              case 14:
                _context5.t2 = _context5.sent;
                _context5.t3 = gasPrice;
                _context5.t4 = {
                  from: _context5.t1,
                  gas: _context5.t2,
                  gasPrice: _context5.t3
                };
                return _context5.abrupt('return', _context5.t0.send.call(_context5.t0, _context5.t4));

              case 18:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function setQtyStepFunction(_x14, _x15, _x16, _x17, _x18) {
        return _ref5.apply(this, arguments);
      }

      return setQtyStepFunction;
    }()

    /**
     * Return the buying ETH based rate. The rate might be vary with
     * different quantity.
     * @param {string} token - token address
     * @param {number} qty - quantity of token
     * @param {number} [currentBlockNumber=0] - current block number, default to
     * use latest known block number.
     * @return {number} - buy rate
     */

  }, {
    key: 'getBuyRates',
    value: function getBuyRates(token, qty) {
      var currentBlockNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      return this.contract.methods.getRate(token, currentBlockNumber, true, qty).call();
    }

    /**
     * Return the buying ETH based rate. The rate might be vary with
     * different quantity.
     * @param {string} token - token address
     * @param {number} qty - quantity of token
     * @param {number} [currentBlockNumber=0] - current block number
     * known block number.
     */

  }, {
    key: 'getSellRates',
    value: function getSellRates(token, qty) {
      var currentBlockNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      return this.contract.methods.getRate(token, currentBlockNumber, false, qty).call();
    }

    /**
     * Set the buying rate for given token.
     * @param {object} operatorAddress - address of the operator account
     * @param {RateSetting[]} rates - token address
     * @param {number} [currentBlockNumber=0] - current block number
     * @param {number} gasPrice (optional) - the gasPrice desired for the tx
     */

  }, {
    key: 'setRate',
    value: function () {
      var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(operatorAddress, rates) {
        var _this3 = this;

        var currentBlockNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var gasPrice = arguments[3];
        var indices, data, compactInputs, tx, gas;
        return _regenerator2.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return (0, _permission_assert.assertOperator)(this, operatorAddress);

              case 2:
                _context8.next = 4;
                return rates.reduce(function () {
                  var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(acc, val) {
                    var accumulator;
                    return _regenerator2.default.wrap(function _callee6$(_context6) {
                      while (1) {
                        switch (_context6.prev = _context6.next) {
                          case 0:
                            _context6.next = 2;
                            return acc.then();

                          case 2:
                            accumulator = _context6.sent;
                            _context6.next = 5;
                            return _this3.getTokenIndices(val.address);

                          case 5:
                            accumulator[val.address] = _context6.sent;
                            return _context6.abrupt('return', _promise2.default.resolve(accumulator));

                          case 7:
                          case 'end':
                            return _context6.stop();
                        }
                      }
                    }, _callee6, _this3);
                  }));

                  return function (_x24, _x25) {
                    return _ref7.apply(this, arguments);
                  };
                }(), _promise2.default.resolve({}));

              case 4:
                indices = _context8.sent;
                _context8.next = 7;
                return rates.reduce(function () {
                  var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7(acc, val) {
                    var accumulator, currentBaseBuy, buyCompactData, currentBaseSell, sellCompactData, buyCompact, sellCompact;
                    return _regenerator2.default.wrap(function _callee7$(_context7) {
                      while (1) {
                        switch (_context7.prev = _context7.next) {
                          case 0:
                            _context7.next = 2;
                            return acc.then();

                          case 2:
                            accumulator = _context7.sent;
                            _context7.next = 5;
                            return _this3.contract.methods.getBasicRate(val.address, true).call();

                          case 5:
                            currentBaseBuy = _context7.sent;
                            buyCompactData = new CompactData(val.buy, currentBaseBuy);
                            _context7.next = 9;
                            return _this3.contract.methods.getBasicRate(val.address, false).call();

                          case 9:
                            currentBaseSell = _context7.sent;
                            sellCompactData = new CompactData(val.sell, currentBaseSell);


                            if (buyCompactData.isBaseChanged || sellCompactData.isBaseChanged) {
                              accumulator.tokens.push(val.address);
                              accumulator.baseBuys.push(buyCompactData.base.toString());
                              accumulator.baseSells.push(sellCompactData.base.toString());
                            }
                            buyCompact = buyCompactData.compact.toString();

                            accumulator.compactBuys[val.address] = buyCompact;
                            sellCompact = sellCompactData.compact.toString();

                            accumulator.compactSells[val.address] = sellCompact;

                            return _context7.abrupt('return', _promise2.default.resolve(accumulator));

                          case 17:
                          case 'end':
                            return _context7.stop();
                        }
                      }
                    }, _callee7, _this3);
                  }));

                  return function (_x26, _x27) {
                    return _ref8.apply(this, arguments);
                  };
                }(), _promise2.default.resolve({
                  tokens: [],
                  baseBuys: [],
                  baseSells: [],
                  compactBuys: {},
                  compactSells: {}
                }));

              case 7:
                data = _context8.sent;
                compactInputs = buildCompactBulk(data.compactBuys, data.compactSells, indices);

                compactInputs.buyResults = compactInputs.buyResults.map(function (val) {
                  return _web2.default.utils.padLeft(_web2.default.utils.bytesToHex(val), 14);
                });
                compactInputs.sellResults = compactInputs.sellResults.map(function (val) {
                  return _web2.default.utils.padLeft(_web2.default.utils.bytesToHex(val), 14);
                });

                tx = void 0;

                if (data.tokens.length === 0) {
                  tx = this.contract.methods.setCompactData(compactInputs.buyResults, compactInputs.sellResults, currentBlockNumber, compactInputs.indexResults);
                } else {
                  tx = this.contract.methods.setBaseRate(data.tokens, data.baseBuys, data.baseSells, compactInputs.buyResults, compactInputs.sellResults, currentBlockNumber, compactInputs.indexResults);
                }

                _context8.next = 15;
                return tx.estimateGas({ from: operatorAddress });

              case 15:
                gas = _context8.sent;
                return _context8.abrupt('return', tx.send({
                  from: operatorAddress,
                  gas: gas,
                  gasPrice: gasPrice
                }));

              case 17:
              case 'end':
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function setRate(_x22, _x23) {
        return _ref6.apply(this, arguments);
      }

      return setRate;
    }()
  }]);
  return ConversionRatesContract;
}(_base_contract2.default);

exports.default = ConversionRatesContract;